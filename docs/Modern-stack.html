<!doctype html>

<html lang="en">

<!--
  Apply head only for dev environment, this is required for jekyll to
  insert livereload scripts
-->

  <head>



  <meta charset="utf-8">


<title>Modern data warehouse patterns. ELT with Snowflake variants - Typhoon Orchestrator</title>

<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<!-- Define a description for better SEO result -->
<meta name="description" content="Table of contents Table of contents Leveraging semi-structured data for resilience against schema changes Real world example- Personal information Creating a view Removing a column, adding a column Doesn’t this take up more space than regular tables? Isn’t it slower...">

<!-- Cheome Web App theme color -->
<meta name="theme-color" content="#ff00b4">

<!-- Feed URL -->
<link rel="alternate" href="/feed.xml" type="application/atom+xml">

<!-- Site icons -->
<link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="icon" href="/favicon.png" type="image/png"><link rel="icon" href="/favicon.svg?assets-inline-assets-keep" sizes="any" type="image/svg+xml"><link rel="mask-icon" href="/mask-icon.svg" color="#ff00b4">

<!-- Chrome Web App manifest -->
<link rel="manifest" href="/manifest.json">

<!-- Main CSS -->
<link rel="stylesheet" href="/assets/themes/curtana/css/app.css?assets-inline">

<!-- Canonical links, avoid duplicate content problems -->
<link rel="canonical" href="http://0.0.0.0:4321/Modern-stack.html">

<!-- DNS prefetching for static files -->


<!-- Head hooks -->




<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3LJTY1R5E0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3LJTY1R5E0');
</script>


  </head>

<!-- Open Graph and Twitter Cards support -->
<meta property="og:type" content="article">
<meta property="og:site_name" content="Typhoon Orchestrator">
<meta property="og:title" content="Modern data warehouse patterns. ELT with Snowflake variants">
<meta property="og:url" content="http://0.0.0.0:4321/Modern-stack.html">
<meta property="og:description" content="Table of contents Table of contents Leveraging semi-structured data for resilience against schema changes Real world example- Personal information Creating a view Removing a column, adding a column Doesn’t this take up more space than regular tables? Isn’t it slower...">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--HQh30rs7--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/o1zxpq2orcx5c727lul4.jpeg">

<meta name="twitter:card" content="summary_large_image">


  <meta name="twitter:site" content="@sparanoid">





  <meta property="article:published_time" content="2022-07-01T00:00:00-07:00">
  <meta property="article:modified_time" content="2022-07-17T04:34:46-07:00">
  <meta name="twitter:label1" value="Words">
  <meta name="twitter:data1" value="1906 words">
  <meta name="twitter:label2" value="Reading time">
  <meta name="twitter:data2" value="9 mins">

<!-- Post specified styles -->
<style data-assets-inline>
  :root {
    

    

    

    
  }

  body {
    
  }

  
  
    
</style>
<!-- Main navigation with current page / categoriy highlighted -->

<div class="header-site">
	<div class="heder__body">
		<div class="header__container">
			<nav class="navigation header__menu menu-header">
				<div class="menu-header__logo"><a href=""><img src="/assets/img/logo.svg" alt="Logo"></a></div>
				<ul class="menu-header__list">
					<li >
						<a href="/#features" target="">Features</a>
						</li>
					<li >
						<a href="/#plugins" target="">Plugins</a>
						</li>
					<li >
						<a href="/#blog" target="">Blog</a>
						</li>
					<li >
						<a href="https://typhoon-data-org.github.io/typhoon-orchestrator/getting-started/installation/" target="_blank">Docs</a>
						</li>
					
					<li><iframe src="https://ghbtns.com/github-btn.html?user=typhoon-data-org&repo=typhoon-orchestrator&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="Star"></iframe></li>
				</ul>
				<button type="button" class="menu-header__burger-menu"><span></span></button>
			</nav>
		</div>
	</div>
</div><!-- Main content wrap -->
<main class="content " role=main>
  <!-- Post-wide custom CSS -->


<!-- Article wrapper, limit width -->
<article lang="en">

  <!-- Post title -->
  <header style="background-image: url('https://res.cloudinary.com/practicaldev/image/fetch/s--HQh30rs7--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/o1zxpq2orcx5c727lul4.jpeg'); background-color: #FFF; background-size: cover; background-position: center center; background-repeat: no-repeat; color: #000;">

    <h1 class="" title="Modern data warehouse patterns. ELT with Snowflake variants" data-title="Modern data warehouse patterns. ELT with Snowflake variants">
      Modern data warehouse patterns. ELT with Snowflake variants<span class="dot dot--post"> </span>
    </h1>

    
      <small>
        By <span rel="author">biellls</span>
        on <time datetime="2022-07-01T00:00:00-07:00">Jul 1, 2022</time>
      </small>
    

    

  </header>

  <!-- Post content -->
  <div class="post-content">
    <h4 id="table-of-contents">Table of contents</h4>
<ul id="markdown-toc">
  <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of contents</a></li>
  <li><a href="#leveraging-semi-structured-data-for-resilience-against-schema-changes" id="markdown-toc-leveraging-semi-structured-data-for-resilience-against-schema-changes">Leveraging semi-structured data for resilience against schema changes</a></li>
  <li><a href="#real-world-example--personal-information" id="markdown-toc-real-world-example--personal-information">Real world example- Personal information</a>    <ul>
      <li><a href="#creating-a-view" id="markdown-toc-creating-a-view">Creating a view</a></li>
      <li><a href="#removing-a-column-adding-a-column" id="markdown-toc-removing-a-column-adding-a-column">Removing a column, adding a column</a></li>
      <li><a href="#doesnt-this-take-up-more-space-than-regular-tables-isnt-it-slower-to-query" id="markdown-toc-doesnt-this-take-up-more-space-than-regular-tables-isnt-it-slower-to-query">Doesn’t this take up more space than regular tables? Isn’t it slower to query?</a></li>
      <li><a href="#improving-performance" id="markdown-toc-improving-performance">Improving performance</a></li>
    </ul>
  </li>
  <li><a href="#what-is-the-best-way-to-load-the-data" id="markdown-toc-what-is-the-best-way-to-load-the-data">What is the best way to load the data?</a></li>
  <li><a href="#bottom-line" id="markdown-toc-bottom-line">Bottom Line</a></li>
  <li><a href="#what-are-the-best-tools-to-load-data-like-this" id="markdown-toc-what-are-the-best-tools-to-load-data-like-this">What are the best tools to load data like this?</a></li>
  <li><a href="#sources" id="markdown-toc-sources">Sources</a></li>
</ul>

<h2 id="leveraging-semi-structured-data-for-resilience-against-schema-changes">Leveraging semi-structured data for resilience against schema changes</h2>

<p>As data warehouse technologies get cheaper and better, ELT is gaining momentum over ETL. In this article we will show you how to leverage Snowflake’s semi-structured data to build integrations that are highly resistant to changes in schema while staying performant. Schema changes are one of the most common things that can break a data pipeline (adding and removing fields, changes in types or length of the data etc.) so it is extremely useful to protect yourself against them.</p>

<h2 id="real-world-example--personal-information">Real world example- Personal information</h2>

<p>Let’s assume we have a table with basic information about our clients. The goal is to load the information into snowflake unchanged.</p>

<table>
  <thead>
    <tr>
      <th>name</th>
      <th>surname</th>
      <th>age</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Anne</td>
      <td>Houston</td>
      <td>38</td>
    </tr>
    <tr>
      <td>John</td>
      <td>Doe</td>
      <td>22</td>
    </tr>
    <tr>
      <td>William</td>
      <td>Williams</td>
      <td>27</td>
    </tr>
  </tbody>
</table>

<p>We would usually create the following table in Snowflake:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">clients</span> <span class="p">(</span><span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">,</span> <span class="n">surname</span> <span class="nb">VARCHAR</span><span class="p">,</span> <span class="n">age</span> <span class="n">NUMBER</span><span class="p">);</span>
</code></pre></div></div>

<p>Notice how we don’t specify the varchar’s length or the number’s precision and scale. This is preferable because snowflake will automatically use the minimum size needed to store the data efficiently, and if the source system changes the length of a varchar, or the precision of a number your flows won’t break. An exception is when a number has decimals we will need to specify a precision and scale.</p>

<p>But if we do that, our integration will fail if a field is removed, and if a field is added we won’t notice. We are not resilient to schema changes. To solve that we will instead create a table with just one variant field where we will load all the data, no matter what fields it has.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">clients_raw</span> <span class="p">(</span><span class="n">src</span> <span class="n">VARIANT</span><span class="p">);</span>
</code></pre></div></div>

<p>In order to load the data we can dump it as JSON into a stage.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="n">FILE</span> <span class="n">FORMAT</span> <span class="n">json_format</span> <span class="k">TYPE</span> <span class="o">=</span> <span class="n">JSON</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="n">STAGE</span> <span class="n">mystage</span> <span class="n">FILE_FORMAT</span> <span class="o">=</span> <span class="n">json_format</span><span class="p">;</span>
</code></pre></div></div>

<p>Let’s create a file with some JSON data to load into the table. Run the following in a shell:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'{"name": "Anne", "surname": "Houston", "age": 37}'</span> <span class="o">&gt;</span> /tmp/data.json
<span class="nb">echo</span> <span class="s1">'{"name": "John", "surname": "Doe", "age": 21}'</span> <span class="o">&gt;&gt;</span> /tmp/data.json
<span class="nb">echo</span> <span class="s1">'{"name": "William", "surname": "Williams", "age": 26}'</span> <span class="o">&gt;&gt;</span> /tmp/data.json
</code></pre></div></div>

<p>Next we run this in snowflake to upload the data to a stage and then load the data into the table:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">put</span> <span class="n">file</span><span class="p">:</span><span class="o">///</span><span class="n">tmp</span><span class="o">/</span><span class="k">data</span><span class="p">.</span><span class="n">json</span> <span class="o">@</span><span class="n">mystage</span>
<span class="k">COPY</span> <span class="k">INTO</span> <span class="n">clients_raw</span> <span class="k">FROM</span> <span class="o">@</span><span class="n">mystage</span><span class="o">/</span><span class="k">data</span><span class="p">.</span><span class="n">json</span> <span class="n">FILE_FORMAT</span> <span class="o">=</span> <span class="n">json_format</span><span class="p">;</span>
</code></pre></div></div>

<p>We can now query the data as:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">min</span><span class="p">(</span><span class="n">src</span><span class="p">:</span><span class="n">age</span><span class="p">)</span> <span class="k">as</span> <span class="n">age</span> <span class="k">from</span> <span class="n">clients_raw</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="creating-a-view">Creating a view</h3>

<p>It is easy to query the data, but it can be verbose and a little confusing to analysts who have never worked with unstructured data. In order to make it transparent to the end user we can create a view that turns it into structured data.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">clients</span> <span class="k">AS</span>
<span class="k">SELECT</span>
<span class="n">src</span><span class="p">:</span><span class="n">name</span><span class="p">::</span><span class="nb">VARCHAR</span> <span class="k">AS</span> <span class="n">name</span><span class="p">,</span>
<span class="n">src</span><span class="p">:</span><span class="n">surname</span><span class="p">::</span><span class="nb">VARCHAR</span> <span class="k">AS</span> <span class="n">surname</span><span class="p">,</span>
<span class="n">src</span><span class="p">:</span><span class="n">age</span><span class="p">::</span><span class="nb">NUMERIC</span> <span class="k">AS</span> <span class="n">age</span>
<span class="k">FROM</span> <span class="n">clients_raw</span><span class="p">;</span>
</code></pre></div></div>

<p>The same query from before would now be:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">min</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">as</span> <span class="n">age</span> <span class="k">from</span> <span class="n">clients</span><span class="p">;</span>
</code></pre></div></div>

<p>And now it’s indistinguishable from a structured table from the user’s point of view.</p>

<h3 id="removing-a-column-adding-a-column">Removing a column, adding a column</h3>

<p>Suppose that database admins realized that storing age in a column is not ideal, since it needs to be updated every time a client has a birthday. Instead he decides to drop the age column and store a date with their birthday. The new table is as follows:</p>

<table>
  <thead>
    <tr>
      <th>name</th>
      <th>surname</th>
      <th>birthday</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Anne</td>
      <td>Houston</td>
      <td>1984-03-12</td>
    </tr>
    <tr>
      <td>John</td>
      <td>Doe</td>
      <td>2000-01-03</td>
    </tr>
    <tr>
      <td>William</td>
      <td>Williams</td>
      <td>1995-02-04</td>
    </tr>
  </tbody>
</table>

<p>Let’s create the new data:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'{"name": "Anne", "surname": "Houston", "birthday": "1984-03-12"}'</span> <span class="o">&gt;</span> /tmp/data.json
<span class="nb">echo</span> <span class="s1">'{"name": "John", "surname": "Doe", "birthday": "2000-01-03"}'</span> <span class="o">&gt;&gt;</span> /tmp/data.json
<span class="nb">echo</span> <span class="s1">'{"name": "William", "surname": "Williams", "birthday": "1995-02-04"}'</span> <span class="o">&gt;&gt;</span> /tmp/data.json
</code></pre></div></div>

<p>We would usually append the data, but to make this tutorial simple we will just replace the old data with the new one.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">clients_raw</span><span class="p">;</span>
<span class="k">COPY</span> <span class="k">INTO</span> <span class="n">clients_raw</span> <span class="k">FROM</span> <span class="o">@</span><span class="n">mystage</span><span class="o">/</span><span class="k">data</span><span class="p">.</span><span class="n">json</span> <span class="n">FILE_FORMAT</span> <span class="o">=</span> <span class="n">json_format</span><span class="p">;</span>
<span class="n">put</span> <span class="n">file</span><span class="p">:</span><span class="o">///</span><span class="n">tmp</span><span class="o">/</span><span class="k">data</span><span class="p">.</span><span class="n">json</span> <span class="o">@</span><span class="n">mystage</span><span class="p">;</span>
</code></pre></div></div>

<p>Since we store all available data as a variant our integration will not break. The view would not break either, but the age would show as null (try <code class="language-plaintext highlighter-rouge">SELECT * FROM clients</code>). The only thing we need to do to take advantage of the new field is to update the view. For backwards compatibility we will still include the age as a calculation.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">VIEW</span> <span class="n">clients</span> <span class="k">AS</span>
<span class="k">SELECT</span>
<span class="n">src</span><span class="p">:</span><span class="n">name</span><span class="p">::</span><span class="nb">VARCHAR</span> <span class="k">as</span> <span class="n">name</span><span class="p">,</span>
<span class="n">src</span><span class="p">:</span><span class="n">surname</span><span class="p">::</span><span class="nb">VARCHAR</span> <span class="k">as</span> <span class="n">surname</span><span class="p">,</span>
<span class="n">src</span><span class="p">:</span><span class="n">birthday</span><span class="p">::</span><span class="nb">DATE</span> <span class="k">as</span> <span class="n">birthday</span><span class="p">,</span>
<span class="n">DATEDIFF</span><span class="p">(</span><span class="s1">'years'</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span><span class="n">birthday</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">())</span> <span class="k">as</span> <span class="n">age</span>
<span class="k">FROM</span> <span class="n">clients_raw</span><span class="p">;</span>
</code></pre></div></div>

<p>That’s it, our pipelines never broke and there’s no need to change our data flows or source table definitions!</p>

<p>If a new field gets added to the table and no one notices it’s still getting staged into snowflake in the variant so the moment someone requests the field in the view we’ll be able to see it, without needing to backfill the data.</p>

<h3 id="doesnt-this-take-up-more-space-than-regular-tables-isnt-it-slower-to-query">Doesn’t this take up more space than regular tables? Isn’t it slower to query?</h3>

<p>This excerpt from <a href="https://docs.snowflake.com/en/user-guide/semistructured-considerations.html#storing-semi-structured-data-in-a-variant-column-vs-flattening-the-nested-structure">Snowflake’s docs</a> answers the question:</p>

<blockquote>
  <p>For data that is mostly regular and uses only native types (strings and integers), the storage requirements and query performance for operations on relational data and data in a VARIANT column is very similar.
For better pruning and less storage consumption, we recommend flattening your object and key data into separate relational columns if your semi-structured data includes:</p>
</blockquote>

<ul>
  <li>Dates and timestamps, especially non-ISO 8601dates and timestamps, as string values</li>
  <li>Numbers within strings</li>
  <li>Arrays</li>
</ul>

<p>Non-native values such as dates and timestamps are stored as strings when loaded into a VARIANT column, so operations on these values could be slower and also consume more space than when stored in a relational column with the corresponding data type.</p>
<blockquote>

</blockquote>

<p>So in terms of performance and storage it should be really similar albeit a little slower. An exception would be if we need to query the birthday because it’s stored as a string, as we will see in the following section.</p>

<h3 id="improving-performance">Improving performance</h3>

<p>Because variants store dates as strings, they are not as efficient to filter by. This is only an issue if the table is large and you intend to query the table by that date. Let’s see an example of how to improve performance in that case:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">TABLE</span> <span class="n">clients_raw</span> <span class="p">(</span><span class="n">src</span> <span class="n">VARIANT</span><span class="p">,</span> <span class="n">birthday</span> <span class="nb">DATE</span><span class="p">);</span>
<span class="k">COPY</span> <span class="k">INTO</span> <span class="n">clients_raw</span> <span class="k">FROM</span> <span class="p">(</span>
<span class="k">select</span>
<span class="err">$</span><span class="mi">1</span> <span class="k">as</span> <span class="n">src</span><span class="p">,</span>
<span class="n">to_date</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">:</span><span class="n">birthday</span><span class="p">)::</span><span class="nb">DATE</span> <span class="k">AS</span> <span class="n">birthday</span>
<span class="k">FROM</span> <span class="o">@</span><span class="n">mystage</span><span class="o">/</span><span class="k">data</span><span class="p">.</span><span class="n">json</span>
<span class="p">)</span> <span class="n">FILE_FORMAT</span> <span class="o">=</span> <span class="n">json_format</span><span class="p">;</span>
</code></pre></div></div>

<p>And modify the view:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">VIEW</span> <span class="n">clients</span>
<span class="k">SELECT</span>
<span class="n">src</span><span class="p">:</span><span class="n">name</span><span class="p">::</span><span class="nb">VARCHAR</span> <span class="k">as</span> <span class="n">name</span><span class="p">,</span>
<span class="n">src</span><span class="p">:</span><span class="n">surname</span><span class="p">::</span><span class="nb">VARCHAR</span> <span class="k">as</span> <span class="n">surname</span><span class="p">,</span>
<span class="n">birthday</span><span class="p">,</span>     <span class="o">//</span> <span class="o">&lt;</span><span class="c1">-- We changed this to get the column directly</span>
<span class="n">DATEDIFF</span><span class="p">(</span><span class="s1">'years'</span><span class="p">,</span> <span class="n">birthday</span><span class="p">,</span> <span class="k">CURRENT_DATE</span><span class="p">())</span> <span class="k">as</span> <span class="n">age</span>  <span class="o">//</span> <span class="o">&lt;</span><span class="c1">-- Here too</span>
<span class="k">FROM</span> <span class="n">clients_raw</span><span class="p">;</span>
</code></pre></div></div>

<p>Now queries filtering by birthday (or getting <code class="language-plaintext highlighter-rouge">MAX(birthday)</code> for example) will be much faster.</p>

<h2 id="what-is-the-best-way-to-load-the-data">What is the best way to load the data?</h2>

<p>The most efficient way to load the data into a table is by using a COPY command since Snowflake can optimize a bulk load. It can’t do that with insert statements. Here are some of the most popular ways to load the data into snowflake, each with their advantges and disadvantages:</p>

<ul>
  <li>CSV: A gzipped CSV is the fastest way to load structured data into snowflake. It takes more space than parquet. It can also be loaded into a variant column with the right casting (see example later). The data can not be loaded easily into a variant.</li>
  <li>JSON: Can be easily loaded into a variant, but it takes a lot of space in your data lake.</li>
  <li>Avro: Built-in schema, easily loaded into a variant or into a structured table. Takes more space than parquet.</li>
  <li>Parquet: Columnar storage that has a better compression than the other options and can easily be loaded into a structured or unstructured table. It is slower than CSV to load into a structured table.</li>
</ul>

<h2 id="bottom-line">Bottom Line</h2>

<p>Loading data into Snowflake using this method is a great way to save you a lot of headaches and minimise data pipeline failures. It is a good rule of thumb to always use this method unless you will be loading an extremely large amount of data and need the extra 20% performance that a  structured table will give you. If you decide to create a structured table instead of using this method be aware that the pipelines will break on any schema change.</p>

<h2 id="what-are-the-best-tools-to-load-data-like-this">What are the best tools to load data like this?</h2>

<p>Any ETL/ELT tool that is flexible enough, for instance Airflow can be adapted to use this method. You can also check out our ETL tool, <a href="/">Typhoon</a>, that encourages this pattern and other modern best practices for data engineering.</p>

<h2 id="sources">Sources</h2>

<p><a href="https://www.snowflake.com/wp-content/uploads/2015/06/Snowflake_Semistructured_Data_WP_1_0_062015.pdf">https://www.snowflake.com/wp-content/uploads/2015/06/Snowflake_Semistructured_Data_WP_1_0_062015.pdf</a></p>

<p><a href="https://docs.snowflake.com/en/user-guide/semistructured-considerations.html#storing-semi-structured-data-in-a-variant-column-vs-flattening-the-nested-structure">https://docs.snowflake.com/en/user-guide/semistructured-considerations.html#storing-semi-structured-data-in-a-variant-column-vs-flattening-the-nested-structure</a></p>


    
    

    
  </div>

</article>

</main>
<!-- Footer section -->

<section class="home__posts posts-home">
		<div class="posts-home__container">
			<h2 id="blog" class="posts-home__title title title_big title_uppercase">BLOG POSTS</h2>
			<div class="posts-home__body">
				<div class="posts-home__item item-posts-left">
					<h3 class="posts-home__subtitle subtitle">Getting-started</h3>
					<div class="posts-home__links">
						<!-- List snippets -->

<!-- Dynamic link color based on post color scheme -->


<!-- Dynamic background color based on post color scheme -->


<section class="list">
  
    

    <!-- External link indicator -->
          
      <!-- Item title -->
      <a class="posts-home__link text" href="https://typhoon-data-org.github.io/typhoon-orchestrator/getting-started/installation/"  target="_blank">Installation</a>
    

  
</section>
<!-- List snippets -->

<!-- Dynamic link color based on post color scheme -->


<!-- Dynamic background color based on post color scheme -->


<section class="list">
  
    

    <!-- External link indicator -->
          
      <!-- Item title -->
      <a class="posts-home__link text" href="https://typhoon-data-org.github.io/typhoon-orchestrator/examples/hello-world/"  target="_blank">Hello World - 5 min walkthrough</a>
    

  
</section>

					</div>
				</div>
				<div class="posts-home__item item-posts-right posts-home__links">
					<h3 class="posts-home__subtitle subtitle">Blog</h3>					
					<!-- List snippets -->

<!-- Dynamic link color based on post color scheme -->


<!-- Dynamic background color based on post color scheme -->


<section class="list">
  
    

    <!-- External link indicator -->
    
      <!-- Item title -->
      <a class="posts-home__link text" href="/typhoon-orchestrator-vision.html" >Why Typhoon?</a>
    

  
</section>
<!-- List snippets -->

<!-- Dynamic link color based on post color scheme -->


<!-- Dynamic background color based on post color scheme -->


<section class="list">
  
    

    <!-- External link indicator -->
    
      <!-- Item title -->
      <a class="posts-home__link text" href="/Airflow.html" >Airflow; Standing on the shoulders of giants</a>
    

  
</section>
<!-- List snippets -->

<!-- Dynamic link color based on post color scheme -->


<!-- Dynamic background color based on post color scheme -->


<section class="list">
  
    

    <!-- External link indicator -->
    
      <!-- Item title -->
      <a class="posts-home__link text" href="/Modern-stack.html" >Modern data warehouse patterns. ELT with Snowflake variants</a>
    

  
</section>
<!-- List snippets -->

<!-- Dynamic link color based on post color scheme -->


<!-- Dynamic background color based on post color scheme -->


<section class="list">
  
    

    <!-- External link indicator -->
    
      <!-- Item title -->
      <a class="posts-home__link text" href="/serverless-telegram-bot-jokes.html" >How to create a Serverless Telegram Bot to send daily jokes to your friends</a>
    

  
</section>

				</div>
			</div>
		</div>
	</section>
	





  

<!-- Theme scripts -->
<script src="/assets/themes/curtana/js/app.js?assets-inline"></script>

<!-- User scripts -->
<script src="/assets/js/user.js?assets-inline"></script>

<!-- Lightense Images -->


<!-- Service Worker  -->


<!-- Google Analytics -->


<!-- Foot hooks -->





<!-- Finale -->
</html>
